# Implementation Plan: OpenAI ChatKit Integration for Todo Chatbot

**Branch**: `001-chatkit-integration` | **Date**: 2026-01-19 | **Spec**: @specs/001-chatkit-integration/spec.md
**Input**: Feature specification from `/specs/001-chatkit-integration/spec.md`

**Note**: This template is filled in by the `/sp.plan` command. See `.specify/templates/commands/plan.md` for the execution workflow.

## Summary

Integrate the official OpenAI ChatKit as the frontend chat interface for the Todo app, enabling natural-language task management via a polished, secure, and stateless UI. The implementation will create a Next.js page at `/frontend/app/chat/page.tsx` that renders ChatKit with proper authentication integration using Better Auth and JWT tokens, communicating with the existing backend endpoint `/api/{user_id}/chat`.

## Technical Context

**Language/Version**: TypeScript/JavaScript (Next.js 16 App Router)
**Primary Dependencies**: `@openai/chatkit`, `@better-auth/react`, `next`, `react`, `react-dom`
**Storage**: Browser local storage for conversation persistence (temporary), backend database for task storage
**Testing**: Jest, React Testing Library (to be determined based on research)
**Target Platform**: Web browser (Chrome, Firefox, Safari, Edge)
**Project Type**: Web application (frontend integration with existing backend API)
**Performance Goals**: Sub-3 second page load time, sub-1 second response time for chat interactions
**Constraints**: Must use only official OpenAI ChatKit components, all requests must include valid JWT authentication, solution must work on localhost and *.vercel.app domains
**Scale/Scope**: Individual user conversations, stateless between sessions, secure per-user isolation

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

### Spec-Driven Development Compliance
- [X] All development will be based on this specification
- [X] Code will be generated by Claude Code from this plan
- [X] No manual code writing will occur
- [X] Specs are the single source of truth

### Mandatory Workflow Compliance
- [X] Following the required sequence: /sp.constitution → /sp.specify → /sp.plan → /sp.task → /sp.implement
- [X] No steps will be skipped
- [X] Implementation will not exceed approved spec
- [X] Adhering to the defined workflow

### Engineering & AI Standards
- [X] Clean, modular architecture with clear separation of concerns
- [X] Explicit state management for conversation persistence
- [X] Deterministic behavior for authentication and API communication
- [X] Reliable mapping of UI events to API calls

### Quality Assurance
- [X] Working implementation will be delivered per spec
- [X] Markdown documentation will be provided
- [X] Implementation will match specification exactly

## Project Structure

### Documentation (this feature)

```text
specs/001-chatkit-integration/
├── plan.md              # This file (/sp.plan command output)
├── research.md          # Phase 0 output (/sp.plan command)
├── data-model.md        # Phase 1 output (/sp.plan command)
├── quickstart.md        # Phase 1 output (/sp.plan command)
├── contracts/           # Phase 1 output (/sp.plan command)
└── tasks.md             # Phase 2 output (/sp.tasks command - NOT created by /sp.plan)
```

### Source Code (repository root)

```text
frontend/
├── app/
│   └── chat/
│       └── page.tsx     # ChatKit integration page
├── .env.local.example   # Domain key configuration example
├── package.json         # Dependencies including @openai/chatkit
└── README.md            # Updated with domain allowlist instructions
```

**Structure Decision**: Web application frontend integration. Selected Option 2 structure as this is a frontend feature that integrates with existing backend API. The implementation focuses on the `/frontend` directory with a new `/chat` page that connects to the existing backend `/api/{user_id}/chat` endpoint.

## Complexity Tracking

> **Fill ONLY if Constitution Check has violations that must be justified**

| Violation | Why Needed | Simpler Alternative Rejected Because |
|-----------|------------|-------------------------------------|
| Third-party UI library integration | OpenAI ChatKit provides necessary conversational interface | Custom UI would require significant development effort and lack ChatKit features |
| External authentication dependency | Better Auth provides secure JWT management | Hardcoding credentials would be insecure |

## Phase 0: Research & Discovery

### Research Tasks

#### R1: Better Auth Session Integration
**Decision**: How to access user_id and JWT token from Better Auth session in Next.js client component
**Rationale**: Need to authenticate API calls with user context
**Alternatives considered**:
- Using Better Auth hooks directly in client component
- Creating a custom hook to abstract the session access
- Server-side props to pass user data to client

#### R2: OpenAI ChatKit Configuration
**Decision**: Proper configuration of ChatKit for domain allowlisting and custom API integration
**Rationale**: ChatKit needs to be configured to work with our domain and API
**Alternatives considered**:
- Standard ChatKit setup with minimal customization
- Custom ChatKit configuration with domain-specific settings
- Wrapper component approach for additional control

#### R3: API Communication Pattern
**Decision**: Best approach to integrate ChatKit's onSendMessage with our backend API
**Rationale**: Need to ensure proper authentication and data flow
**Alternatives considered**:
- Direct fetch calls from onSendMessage handler
- Custom service layer to handle API communication
- Context-based API service for centralized management

## Phase 1: Data Model & API Contracts

### Data Model: Frontend State

#### User Session Entity
- **user_id**: String identifier from Better Auth session
- **jwt_token**: Authentication token for API calls
- **session_valid**: Boolean indicating session validity

#### Conversation Entity
- **conversation_id**: String identifier for conversation persistence
- **messages**: Array of message objects with content and metadata
- **timestamp**: Creation/modification time for ordering

#### Message Entity
- **id**: Unique identifier for the message
- **content**: Text content of the message
- **sender_type**: Enum ('user' | 'assistant')
- **timestamp**: When the message was sent/received

### API Contracts

#### Frontend to Backend Communication
- **Endpoint**: `POST /api/{user_id}/chat`
- **Headers**: `Authorization: Bearer {jwt_token}`
- **Request Body**: `{ message: string, conversation_id?: string }`
- **Response**: `{ response: string, conversation_id: string }`
- **Error Responses**: Standard HTTP error codes with descriptive messages

## Phase 2: Implementation Strategy

### Sprint 1: Environment & Dependencies
- Install `@openai/chatkit` in `/frontend`
- Configure environment variables for domain key
- Set up basic Next.js page structure

### Sprint 2: Authentication Integration
- Implement Better Auth session access
- Retrieve user_id and JWT token
- Prepare authenticated API calls

### Sprint 3: ChatKit Integration
- Create `/frontend/app/chat/page.tsx` with ChatKit component
- Implement `onSendMessage` handler with proper authentication
- Handle conversation persistence with `conversation_id`

### Sprint 4: Testing & Documentation
- Test functionality across different scenarios
- Update README.md with domain allowlist instructions
- Verify deployment compatibility

## Risk Analysis

### High-Risk Items
- **Better Auth integration**: May require specific configuration for client-side access
- **Domain allowlisting**: May have complex setup for Vercel deployment
- **Cross-origin requests**: Potential CORS issues between ChatKit and our API

### Mitigation Strategies
- Thoroughly research Better Auth documentation before implementation
- Test domain configuration early in development
- Implement robust error handling for API communication

## Success Criteria Validation

### Quantitative Validation
- [ ] 100% of users can access the ChatKit UI when visiting `/chat`
- [ ] Page load time under 3 seconds for conversation restoration
- [ ] Successful authentication for all API calls

### Qualitative Validation
- [ ] Natural language processing works as expected with backend
- [ ] Conversations persist reliably across browser sessions
- [ ] Error handling provides clear feedback to users
- [ ] Authentication seamlessly integrates with the chat experience
